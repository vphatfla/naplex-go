// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sqlc_query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkUserExistsByEmail = `-- name: CheckUserExistsByEmail :one

SELECT EXISTS(
    SELECT 1 FROM users WHERE email = $1
)
`

// ============================================
// User Existence Checks
// ============================================
func (q *Queries) CheckUserExistsByEmail(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserExistsByEmail, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUserExistsByGoogleID = `-- name: CheckUserExistsByGoogleID :one
SELECT EXISTS(
    SELECT 1 FROM users WHERE google_id = $1
)
`

func (q *Queries) CheckUserExistsByGoogleID(ctx context.Context, googleID string) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserExistsByGoogleID, googleID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrUpdateUserQuestion = `-- name: CreateOrUpdateUserQuestion :one
INSERT INTO users_questions (uid, qid, status, attempts, saved, hidden)
VALUES ($5, $6, $1::question_status, $2, $3, $4)
ON CONFLICT (uid, qid)
DO UPDATE SET
    status = EXCLUDED.status,
    attempts = EXCLUDED.attempts,
    saved = EXCLUDED.saved,
    hidden = EXCLUDED.hidden,
    updated_at = NOW()
RETURNING uid, qid, status, attempts, saved, hidden, created_at, updated_at
`

type CreateOrUpdateUserQuestionParams struct {
	Column1  QuestionStatus
	Attempts pgtype.Int4
	Saved    pgtype.Bool
	Hidden   pgtype.Bool
	Uid      int32
	Qid      int32
}

func (q *Queries) CreateOrUpdateUserQuestion(ctx context.Context, arg CreateOrUpdateUserQuestionParams) (UsersQuestion, error) {
	row := q.db.QueryRow(ctx, createOrUpdateUserQuestion,
		arg.Column1,
		arg.Attempts,
		arg.Saved,
		arg.Hidden,
		arg.Uid,
		arg.Qid,
	)
	var i UsersQuestion
	err := row.Scan(
		&i.Uid,
		&i.Qid,
		&i.Status,
		&i.Attempts,
		&i.Saved,
		&i.Hidden,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrUpsertUser = `-- name: CreateOrUpsertUser :one
INSERT INTO users (
    google_id,
    email,
    name,
    first_name,
    last_name,
    picture,
    last_login_at
) VALUES (
    $1, $2, $3, $4, $5, $6, NOW()
)
ON CONFLICT (google_id)
DO UPDATE SET
    email = EXCLUDED.email,
    name = EXCLUDED.name,
    first_name = EXCLUDED.first_name,
    last_name = EXCLUDED.last_name,
    picture = EXCLUDED.picture,
    last_login_at = NOW()
RETURNING id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at
`

type CreateOrUpsertUserParams struct {
	GoogleID  string
	Email     string
	Name      string
	FirstName pgtype.Text
	LastName  pgtype.Text
	Picture   pgtype.Text
}

// Used for Google OAuth login - creates user if not exists, updates if exists
func (q *Queries) CreateOrUpsertUser(ctx context.Context, arg CreateOrUpsertUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createOrUpsertUser,
		arg.GoogleID,
		arg.Email,
		arg.Name,
		arg.FirstName,
		arg.LastName,
		arg.Picture,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GoogleID,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.Picture,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (
    google_id,
    email,
    name,
    first_name,
    last_name,
    picture,
    last_login_at
) VALUES (
    $1, $2, $3, $4, $5, $6, NOW()
)
RETURNING id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at
`

type CreateUserParams struct {
	GoogleID  string
	Email     string
	Name      string
	FirstName pgtype.Text
	LastName  pgtype.Text
	Picture   pgtype.Text
}

// ============================================
// User Creation and Authentication
// ============================================
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.GoogleID,
		arg.Email,
		arg.Name,
		arg.FirstName,
		arg.LastName,
		arg.Picture,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GoogleID,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.Picture,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users
WHERE id = $1
`

// ============================================
// User Deletion
// ============================================
func (q *Queries) DeleteUser(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const deleteUserByEmail = `-- name: DeleteUserByEmail :exec
DELETE FROM users
WHERE email = $1
`

func (q *Queries) DeleteUserByEmail(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, deleteUserByEmail, email)
	return err
}

const getAllFailedQuestion = `-- name: GetAllFailedQuestion :many
SELECT
    uq.uid, uq.qid, uq.status, uq.attempts, uq.saved, uq.hidden, uq.created_at, uq.updated_at,
    q.id, q.title, q.question, q.multiple_choices, q.correct_answer, q.explanation, q.keywords, q.link
FROM users_questions uq
JOIN questions q ON q.id = uq.qid
WHERE uq.uid = $1 AND uq.status = 'FAILED'::question_status
`

type GetAllFailedQuestionRow struct {
	Uid             int32
	Qid             int32
	Status          NullQuestionStatus
	Attempts        pgtype.Int4
	Saved           pgtype.Bool
	Hidden          pgtype.Bool
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	ID              int32
	Title           string
	Question        string
	MultipleChoices string
	CorrectAnswer   string
	Explanation     pgtype.Text
	Keywords        pgtype.Text
	Link            pgtype.Text
}

func (q *Queries) GetAllFailedQuestion(ctx context.Context, uid int32) ([]GetAllFailedQuestionRow, error) {
	rows, err := q.db.Query(ctx, getAllFailedQuestion, uid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllFailedQuestionRow
	for rows.Next() {
		var i GetAllFailedQuestionRow
		if err := rows.Scan(
			&i.Uid,
			&i.Qid,
			&i.Status,
			&i.Attempts,
			&i.Saved,
			&i.Hidden,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID,
			&i.Title,
			&i.Question,
			&i.MultipleChoices,
			&i.CorrectAnswer,
			&i.Explanation,
			&i.Keywords,
			&i.Link,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPassedQuestion = `-- name: GetAllPassedQuestion :many
SELECT
    uq.uid, uq.qid, uq.status, uq.attempts, uq.saved, uq.hidden, uq.created_at, uq.updated_at,
    q.id, q.title, q.question, q.multiple_choices, q.correct_answer, q.explanation, q.keywords, q.link
FROM users_questions uq
JOIN questions q ON q.id = uq.qid
WHERE uq.uid = $1 AND uq.status = 'PASSED'::question_status
`

type GetAllPassedQuestionRow struct {
	Uid             int32
	Qid             int32
	Status          NullQuestionStatus
	Attempts        pgtype.Int4
	Saved           pgtype.Bool
	Hidden          pgtype.Bool
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	ID              int32
	Title           string
	Question        string
	MultipleChoices string
	CorrectAnswer   string
	Explanation     pgtype.Text
	Keywords        pgtype.Text
	Link            pgtype.Text
}

func (q *Queries) GetAllPassedQuestion(ctx context.Context, uid int32) ([]GetAllPassedQuestionRow, error) {
	rows, err := q.db.Query(ctx, getAllPassedQuestion, uid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPassedQuestionRow
	for rows.Next() {
		var i GetAllPassedQuestionRow
		if err := rows.Scan(
			&i.Uid,
			&i.Qid,
			&i.Status,
			&i.Attempts,
			&i.Saved,
			&i.Hidden,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID,
			&i.Title,
			&i.Question,
			&i.MultipleChoices,
			&i.CorrectAnswer,
			&i.Explanation,
			&i.Keywords,
			&i.Link,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailyNewUsers = `-- name: GetDailyNewUsers :many
SELECT
    DATE(created_at) as date,
    COUNT(*) as new_users
FROM users
WHERE created_at >= $1
GROUP BY DATE(created_at)
ORDER BY date DESC
`

type GetDailyNewUsersRow struct {
	Date     pgtype.Date
	NewUsers int64
}

func (q *Queries) GetDailyNewUsers(ctx context.Context, createdAt pgtype.Timestamptz) ([]GetDailyNewUsersRow, error) {
	rows, err := q.db.Query(ctx, getDailyNewUsers, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyNewUsersRow
	for rows.Next() {
		var i GetDailyNewUsersRow
		if err := rows.Scan(&i.Date, &i.NewUsers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionByID = `-- name: GetQuestionByID :one
SELECT id, title, question, multiple_choices, correct_answer, explanation, keywords, link FROM questions WHERE id = $1
`

func (q *Queries) GetQuestionByID(ctx context.Context, id int32) (Question, error) {
	row := q.db.QueryRow(ctx, getQuestionByID, id)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Question,
		&i.MultipleChoices,
		&i.CorrectAnswer,
		&i.Explanation,
		&i.Keywords,
		&i.Link,
	)
	return i, err
}

const getRandomDailyQuestions = `-- name: GetRandomDailyQuestions :many
SELECT
    q.id, q.title, q.question, q.multiple_choices, q.correct_answer, q.explanation, q.keywords, q.link,
    COALESCE(q.id, uq.qid) AS qid,
    COALESCE(uq.status, 'NA'::question_status) AS status,
    COALESCE(uq.attempts, 0) AS attempts,
    COALESCE(uq.saved, FALSE) AS saved,
    COALESCE(uq.hidden, FALSE) AS hidden
FROM
    questions q
LEFT JOIN
    users_questions uq ON uq.qid = q.id AND uq.uid = $1
WHERE
    uq.uid IS NULL -- Junction record do not exists
    OR (
        uq.status IN ('FAILED'::question_status, 'NA'::question_status)
        AND
        uq.hidden = FALSE
    )
ORDER BY RANDOM() --randomly order selection
LIMIT $2
`

type GetRandomDailyQuestionsParams struct {
	Uid   int32
	Limit int32
}

type GetRandomDailyQuestionsRow struct {
	ID              int32
	Title           string
	Question        string
	MultipleChoices string
	CorrectAnswer   string
	Explanation     pgtype.Text
	Keywords        pgtype.Text
	Link            pgtype.Text
	Qid             int32
	Status          NullQuestionStatus
	Attempts        int32
	Saved           bool
	Hidden          bool
}

func (q *Queries) GetRandomDailyQuestions(ctx context.Context, arg GetRandomDailyQuestionsParams) ([]GetRandomDailyQuestionsRow, error) {
	rows, err := q.db.Query(ctx, getRandomDailyQuestions, arg.Uid, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRandomDailyQuestionsRow
	for rows.Next() {
		var i GetRandomDailyQuestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Question,
			&i.MultipleChoices,
			&i.CorrectAnswer,
			&i.Explanation,
			&i.Keywords,
			&i.Link,
			&i.Qid,
			&i.Status,
			&i.Attempts,
			&i.Saved,
			&i.Hidden,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at FROM users
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GoogleID,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.Picture,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const getUserByGoogleID = `-- name: GetUserByGoogleID :one
SELECT id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at FROM users
WHERE google_id = $1
`

func (q *Queries) GetUserByGoogleID(ctx context.Context, googleID string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByGoogleID, googleID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GoogleID,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.Picture,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one

SELECT id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at FROM users
WHERE id = $1
`

// ============================================
// User Retrieval
// ============================================
func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GoogleID,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.Picture,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const getUserQuestion = `-- name: GetUserQuestion :one
SELECT uid, qid, status, attempts, saved, hidden, created_at, updated_at FROM users_questions
WHERE uid = $1 AND qid = $2
`

type GetUserQuestionParams struct {
	Uid int32
	Qid int32
}

func (q *Queries) GetUserQuestion(ctx context.Context, arg GetUserQuestionParams) (UsersQuestion, error) {
	row := q.db.QueryRow(ctx, getUserQuestion, arg.Uid, arg.Qid)
	var i UsersQuestion
	err := row.Scan(
		&i.Uid,
		&i.Qid,
		&i.Status,
		&i.Attempts,
		&i.Saved,
		&i.Hidden,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUsersByIDs = `-- name: GetUsersByIDs :many
SELECT id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at FROM users
WHERE id = ANY($1::int[])
ORDER BY created_at DESC
`

func (q *Queries) GetUsersByIDs(ctx context.Context, dollar_1 []int32) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.GoogleID,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.Picture,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertQuestion = `-- name: InsertQuestion :one
INSERT INTO questions (title, question, multiple_choices, correct_answer, explanation, keywords, link)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type InsertQuestionParams struct {
	Title           string
	Question        string
	MultipleChoices string
	CorrectAnswer   string
	Explanation     pgtype.Text
	Keywords        pgtype.Text
	Link            pgtype.Text
}

func (q *Queries) InsertQuestion(ctx context.Context, arg InsertQuestionParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertQuestion,
		arg.Title,
		arg.Question,
		arg.MultipleChoices,
		arg.CorrectAnswer,
		arg.Explanation,
		arg.Keywords,
		arg.Link,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const listUsers = `-- name: ListUsers :many
SELECT id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at FROM users
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.GoogleID,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.Picture,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByCreatedDate = `-- name: ListUsersByCreatedDate :many
SELECT id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at FROM users
WHERE created_at >= $1 AND created_at <= $2
ORDER BY created_at DESC
`

type ListUsersByCreatedDateParams struct {
	CreatedAt   pgtype.Timestamptz
	CreatedAt_2 pgtype.Timestamptz
}

func (q *Queries) ListUsersByCreatedDate(ctx context.Context, arg ListUsersByCreatedDateParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsersByCreatedDate, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.GoogleID,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.Picture,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsersByEmail = `-- name: SearchUsersByEmail :many
SELECT id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at FROM users
WHERE email ILIKE '%' || $1 || '%'
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type SearchUsersByEmailParams struct {
	Column1 pgtype.Text
	Limit   int32
	Offset  int32
}

func (q *Queries) SearchUsersByEmail(ctx context.Context, arg SearchUsersByEmailParams) ([]User, error) {
	rows, err := q.db.Query(ctx, searchUsersByEmail, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.GoogleID,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.Picture,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsersByName = `-- name: SearchUsersByName :many
SELECT id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at FROM users
WHERE
    name ILIKE '%' || $1 || '%' OR
    first_name ILIKE '%' || $1 || '%' OR
    last_name ILIKE '%' || $1 || '%'
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type SearchUsersByNameParams struct {
	Column1 pgtype.Text
	Limit   int32
	Offset  int32
}

func (q *Queries) SearchUsersByName(ctx context.Context, arg SearchUsersByNameParams) ([]User, error) {
	rows, err := q.db.Query(ctx, searchUsersByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.GoogleID,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.Picture,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateQuestion = `-- name: UpdateQuestion :one
UPDATE questions
SET title = $1, question = $2, multiple_choices = $3, correct_answer = $4, explanation = $5, keywords = $6, link = $7
WHERE id = $8
RETURNING id
`

type UpdateQuestionParams struct {
	Title           string
	Question        string
	MultipleChoices string
	CorrectAnswer   string
	Explanation     pgtype.Text
	Keywords        pgtype.Text
	Link            pgtype.Text
	ID              int32
}

func (q *Queries) UpdateQuestion(ctx context.Context, arg UpdateQuestionParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateQuestion,
		arg.Title,
		arg.Question,
		arg.MultipleChoices,
		arg.CorrectAnswer,
		arg.Explanation,
		arg.Keywords,
		arg.Link,
		arg.ID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateUserEmail = `-- name: UpdateUserEmail :one
UPDATE users
SET email = $2
WHERE id = $1
RETURNING id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at
`

type UpdateUserEmailParams struct {
	ID    int32
	Email string
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserEmail, arg.ID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GoogleID,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.Picture,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const updateUserLastLogin = `-- name: UpdateUserLastLogin :exec
UPDATE users
SET last_login_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateUserLastLogin(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, updateUserLastLogin, id)
	return err
}

const updateUserPicture = `-- name: UpdateUserPicture :one
UPDATE users
SET picture = $2
WHERE id = $1
RETURNING id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at
`

type UpdateUserPictureParams struct {
	ID      int32
	Picture pgtype.Text
}

func (q *Queries) UpdateUserPicture(ctx context.Context, arg UpdateUserPictureParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserPicture, arg.ID, arg.Picture)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GoogleID,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.Picture,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const updateUserProfile = `-- name: UpdateUserProfile :one

UPDATE users
SET
    name = COALESCE($2, name),
    first_name = COALESCE($3, first_name),
    last_name = COALESCE($4, last_name),
    picture = COALESCE($5, picture)
WHERE id = $1
RETURNING id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at
`

type UpdateUserProfileParams struct {
	ID        int32
	Name      string
	FirstName pgtype.Text
	LastName  pgtype.Text
	Picture   pgtype.Text
}

// ============================================
// User Updates
// ============================================
func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserProfile,
		arg.ID,
		arg.Name,
		arg.FirstName,
		arg.LastName,
		arg.Picture,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GoogleID,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.Picture,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}
