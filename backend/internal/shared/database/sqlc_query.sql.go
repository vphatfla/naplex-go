// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sqlc_query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkUserExistsByEmail = `-- name: CheckUserExistsByEmail :one

SELECT EXISTS(
    SELECT 1 FROM users WHERE email = $1
)
`

// ============================================
// User Existence Checks
// ============================================
func (q *Queries) CheckUserExistsByEmail(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserExistsByEmail, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUserExistsByGoogleID = `-- name: CheckUserExistsByGoogleID :one
SELECT EXISTS(
    SELECT 1 FROM users WHERE google_id = $1
)
`

func (q *Queries) CheckUserExistsByGoogleID(ctx context.Context, googleID string) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserExistsByGoogleID, googleID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countRawQuestion = `-- name: CountRawQuestion :one
SELECT COUNT(id) FROM raw_questions
`

func (q *Queries) CountRawQuestion(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countRawQuestion)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (
    google_id,
    email,
    name,
    first_name,
    last_name,
    picture,
    last_login_at
) VALUES (
    $1, $2, $3, $4, $5, $6, NOW()
)
RETURNING id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at
`

type CreateUserParams struct {
	GoogleID  string
	Email     string
	Name      string
	FirstName pgtype.Text
	LastName  pgtype.Text
	Picture   pgtype.Text
}

// ============================================
// User Creation and Authentication
// ============================================
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.GoogleID,
		arg.Email,
		arg.Name,
		arg.FirstName,
		arg.LastName,
		arg.Picture,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GoogleID,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.Picture,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users
WHERE id = $1
`

// ============================================
// User Deletion
// ============================================
func (q *Queries) DeleteUser(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const deleteUserByEmail = `-- name: DeleteUserByEmail :exec
DELETE FROM users
WHERE email = $1
`

func (q *Queries) DeleteUserByEmail(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, deleteUserByEmail, email)
	return err
}

const getDailyNewUsers = `-- name: GetDailyNewUsers :many
SELECT
    DATE(created_at) as date,
    COUNT(*) as new_users
FROM users
WHERE created_at >= $1
GROUP BY DATE(created_at)
ORDER BY date DESC
`

type GetDailyNewUsersRow struct {
	Date     pgtype.Date
	NewUsers int64
}

func (q *Queries) GetDailyNewUsers(ctx context.Context, createdAt pgtype.Timestamptz) ([]GetDailyNewUsersRow, error) {
	rows, err := q.db.Query(ctx, getDailyNewUsers, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyNewUsersRow
	for rows.Next() {
		var i GetDailyNewUsersRow
		if err := rows.Scan(&i.Date, &i.NewUsers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessedQuestionByID = `-- name: GetProcessedQuestionByID :one
SELECT id, title, question, multiple_choices, correct_answer, explanation, keywords, link FROM processed_questions WHERE id = $1
`

func (q *Queries) GetProcessedQuestionByID(ctx context.Context, id int32) (ProcessedQuestion, error) {
	row := q.db.QueryRow(ctx, getProcessedQuestionByID, id)
	var i ProcessedQuestion
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Question,
		&i.MultipleChoices,
		&i.CorrectAnswer,
		&i.Explanation,
		&i.Keywords,
		&i.Link,
	)
	return i, err
}

const getRawQuestionByID = `-- name: GetRawQuestionByID :one
SELECT id, title, raw_question, link FROM raw_questions
WHERE id=$1 LIMIT 1
`

func (q *Queries) GetRawQuestionByID(ctx context.Context, id int32) (RawQuestion, error) {
	row := q.db.QueryRow(ctx, getRawQuestionByID, id)
	var i RawQuestion
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.RawQuestion,
		&i.Link,
	)
	return i, err
}

const getRawQuestionWithRange = `-- name: GetRawQuestionWithRange :many
SELECT id, title, raw_question, link FROM raw_questions
WHERE id >= $1 AND id <= $2
`

type GetRawQuestionWithRangeParams struct {
	ID   int32
	ID_2 int32
}

func (q *Queries) GetRawQuestionWithRange(ctx context.Context, arg GetRawQuestionWithRangeParams) ([]RawQuestion, error) {
	rows, err := q.db.Query(ctx, getRawQuestionWithRange, arg.ID, arg.ID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RawQuestion
	for rows.Next() {
		var i RawQuestion
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.RawQuestion,
			&i.Link,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at FROM users
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GoogleID,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.Picture,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const getUserByGoogleID = `-- name: GetUserByGoogleID :one
SELECT id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at FROM users
WHERE google_id = $1
`

func (q *Queries) GetUserByGoogleID(ctx context.Context, googleID string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByGoogleID, googleID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GoogleID,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.Picture,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one

SELECT id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at FROM users
WHERE id = $1
`

// ============================================
// User Retrieval
// ============================================
func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GoogleID,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.Picture,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const getUsersByIDs = `-- name: GetUsersByIDs :many
SELECT id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at FROM users
WHERE id = ANY($1::int[])
ORDER BY created_at DESC
`

func (q *Queries) GetUsersByIDs(ctx context.Context, dollar_1 []int32) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.GoogleID,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.Picture,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertProcessedQuestion = `-- name: InsertProcessedQuestion :one
INSERT INTO processed_questions (title, question, multiple_choices, correct_answer, explanation, keywords, link)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type InsertProcessedQuestionParams struct {
	Title           string
	Question        string
	MultipleChoices string
	CorrectAnswer   string
	Explanation     pgtype.Text
	Keywords        pgtype.Text
	Link            pgtype.Text
}

func (q *Queries) InsertProcessedQuestion(ctx context.Context, arg InsertProcessedQuestionParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertProcessedQuestion,
		arg.Title,
		arg.Question,
		arg.MultipleChoices,
		arg.CorrectAnswer,
		arg.Explanation,
		arg.Keywords,
		arg.Link,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertRawQuestion = `-- name: InsertRawQuestion :one
INSERT INTO raw_questions (title, raw_question, link)
VALUES ($1, $2, $3)
RETURNING id
`

type InsertRawQuestionParams struct {
	Title       string
	RawQuestion string
	Link        pgtype.Text
}

func (q *Queries) InsertRawQuestion(ctx context.Context, arg InsertRawQuestionParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertRawQuestion, arg.Title, arg.RawQuestion, arg.Link)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const listUsers = `-- name: ListUsers :many
SELECT id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at FROM users
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.GoogleID,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.Picture,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByCreatedDate = `-- name: ListUsersByCreatedDate :many
SELECT id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at FROM users
WHERE created_at >= $1 AND created_at <= $2
ORDER BY created_at DESC
`

type ListUsersByCreatedDateParams struct {
	CreatedAt   pgtype.Timestamptz
	CreatedAt_2 pgtype.Timestamptz
}

func (q *Queries) ListUsersByCreatedDate(ctx context.Context, arg ListUsersByCreatedDateParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsersByCreatedDate, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.GoogleID,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.Picture,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsersByEmail = `-- name: SearchUsersByEmail :many
SELECT id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at FROM users
WHERE email ILIKE '%' || $1 || '%'
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type SearchUsersByEmailParams struct {
	Column1 pgtype.Text
	Limit   int32
	Offset  int32
}

func (q *Queries) SearchUsersByEmail(ctx context.Context, arg SearchUsersByEmailParams) ([]User, error) {
	rows, err := q.db.Query(ctx, searchUsersByEmail, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.GoogleID,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.Picture,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsersByName = `-- name: SearchUsersByName :many
SELECT id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at FROM users
WHERE
    name ILIKE '%' || $1 || '%' OR
    first_name ILIKE '%' || $1 || '%' OR
    last_name ILIKE '%' || $1 || '%'
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type SearchUsersByNameParams struct {
	Column1 pgtype.Text
	Limit   int32
	Offset  int32
}

func (q *Queries) SearchUsersByName(ctx context.Context, arg SearchUsersByNameParams) ([]User, error) {
	rows, err := q.db.Query(ctx, searchUsersByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.GoogleID,
			&i.Email,
			&i.Name,
			&i.FirstName,
			&i.LastName,
			&i.Picture,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProcessedQuestion = `-- name: UpdateProcessedQuestion :one
UPDATE processed_questions
SET title = $1, question = $2, multiple_choices = $3, correct_answer = $4, explanation = $5, keywords = $6, link = $7
WHERE id = $8
RETURNING id
`

type UpdateProcessedQuestionParams struct {
	Title           string
	Question        string
	MultipleChoices string
	CorrectAnswer   string
	Explanation     pgtype.Text
	Keywords        pgtype.Text
	Link            pgtype.Text
	ID              int32
}

func (q *Queries) UpdateProcessedQuestion(ctx context.Context, arg UpdateProcessedQuestionParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateProcessedQuestion,
		arg.Title,
		arg.Question,
		arg.MultipleChoices,
		arg.CorrectAnswer,
		arg.Explanation,
		arg.Keywords,
		arg.Link,
		arg.ID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateRawQuestion = `-- name: UpdateRawQuestion :one
UPDATE raw_questions
SET title = $1, raw_question = $2, link = $3
WHERE id = $4
RETURNING id
`

type UpdateRawQuestionParams struct {
	Title       string
	RawQuestion string
	Link        pgtype.Text
	ID          int32
}

func (q *Queries) UpdateRawQuestion(ctx context.Context, arg UpdateRawQuestionParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateRawQuestion,
		arg.Title,
		arg.RawQuestion,
		arg.Link,
		arg.ID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateUserEmail = `-- name: UpdateUserEmail :one
UPDATE users
SET email = $2
WHERE id = $1
RETURNING id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at
`

type UpdateUserEmailParams struct {
	ID    int32
	Email string
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserEmail, arg.ID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GoogleID,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.Picture,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const updateUserLastLogin = `-- name: UpdateUserLastLogin :exec
UPDATE users
SET last_login_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateUserLastLogin(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, updateUserLastLogin, id)
	return err
}

const updateUserPicture = `-- name: UpdateUserPicture :one
UPDATE users
SET picture = $2
WHERE id = $1
RETURNING id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at
`

type UpdateUserPictureParams struct {
	ID      int32
	Picture pgtype.Text
}

func (q *Queries) UpdateUserPicture(ctx context.Context, arg UpdateUserPictureParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserPicture, arg.ID, arg.Picture)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GoogleID,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.Picture,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const updateUserProfile = `-- name: UpdateUserProfile :one

UPDATE users
SET
    name = COALESCE($2, name),
    first_name = COALESCE($3, first_name),
    last_name = COALESCE($4, last_name),
    picture = COALESCE($5, picture)
WHERE id = $1
RETURNING id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at
`

type UpdateUserProfileParams struct {
	ID        int32
	Name      string
	FirstName pgtype.Text
	LastName  pgtype.Text
	Picture   pgtype.Text
}

// ============================================
// User Updates
// ============================================
func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserProfile,
		arg.ID,
		arg.Name,
		arg.FirstName,
		arg.LastName,
		arg.Picture,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GoogleID,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.Picture,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const upsertUser = `-- name: UpsertUser :one
INSERT INTO users (
    google_id,
    email,
    name,
    first_name,
    last_name,
    picture,
    last_login_at
) VALUES (
    $1, $2, $3, $4, $5, $6, NOW()
)
ON CONFLICT (google_id)
DO UPDATE SET
    email = EXCLUDED.email,
    name = EXCLUDED.name,
    first_name = EXCLUDED.first_name,
    last_name = EXCLUDED.last_name,
    picture = EXCLUDED.picture,
    last_login_at = NOW()
RETURNING id, google_id, email, name, first_name, last_name, picture, created_at, updated_at, last_login_at
`

type UpsertUserParams struct {
	GoogleID  string
	Email     string
	Name      string
	FirstName pgtype.Text
	LastName  pgtype.Text
	Picture   pgtype.Text
}

// Used for Google OAuth login - creates user if not exists, updates if exists
func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRow(ctx, upsertUser,
		arg.GoogleID,
		arg.Email,
		arg.Name,
		arg.FirstName,
		arg.LastName,
		arg.Picture,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GoogleID,
		&i.Email,
		&i.Name,
		&i.FirstName,
		&i.LastName,
		&i.Picture,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}
